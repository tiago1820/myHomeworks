Función Constructora HashTable():
  numBuckets <- 35
  buckets <- nuevo arreglo de tamaño numBuckets

Método hash(key: cualquier tipo): entero
  stringKey <- convertir key a cadena
  hashValue <- 0

  Para cada caracter c en stringKey:
    hashValue <- hashValue + obtener el código numérico de c

  Retornar hashValue % numBuckets

HashTable.prototype.set(key: cadena, value: cualquier tipo): vacío
  Si el tipo de key no es una cadena, lanzar TypeError

  index <- llamar al método hash con key como argumento

  Si buckets[index] no existe:
    buckets[index] <- nuevo arreglo vacío

  Para cada par en buckets[index]:
    Si la clave del par es igual a key:
      Asignar el valor de value al par
      Salir del bucle

  Añadir { key: key, value: value } al final de buckets[index]

HashTable.prototype.get(key: cadena): cualquier tipo o indefinido
  Si el tipo de key no es una cadena, lanzar TypeError

  index <- llamar al método hash con key como argumento

  Si buckets[index] no existe:
    Retornar indefinido

  Para cada par en buckets[index]:
    Si la clave del par es igual a key:
      Retornar el valor del par

  Retornar indefinido

HashTable.prototype.hasKey(key: cadena): booleano
  Si el tipo de key no es una cadena, lanzar TypeError

  index <- llamar al método hash con key como argumento

  Si buckets[index] no existe:
    Retornar falso

  Para cada par en buckets[index]:
    Si la clave del par es igual a key:
      Retornar verdadero

  Retornar falso
